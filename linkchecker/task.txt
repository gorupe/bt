◆action
・CSVimport + チェック。とりあえずCSV形式でインポートできること。
・フィルタリング(検索)。任意の文字列でタイトルとURLを検索できること。
・タグ検索リンク(tag,status,httpcode) => 複数のキーで絞り込めるようにできること。
・ソート。任意のキーでソートできること。
・CSVexport。とりあえずCSV形式でエクスポートできること。
・CSV形式でimportできるテキストボックス(pivotalにあるやつ)。
・ちゃんとしたMVCにする。

＄多データ処理
・同じ感じのドメインの検出。
・重複チェック => チェック基準はどうする？
・サービスとして公開するならば、データベースをユーザー毎にユニークなものが使えるようにする。
・データベース基盤の再検討 => sql? or xml? or yml?
・ignore機能追加
・ページング処理
・checklink押下時に「{処理件数}件処理します。」
・deleterecord終了後「＊＊件処理しました。」
＠文字コードに注意
・各レコード編集画面(tag,status)
＄ajaxバージョン
・Datatablesを使えるようにする。
・非同期ローディング
・リトライ機構をクラスで持つ

◆someday


◆NotToDo
・テストの作成 => rails自体の習熟度が低いため
・UIの考察 => 機能を優先するため
・バリデーション => 厳格なフォーマットはまだ不要
・一斉にアクセスして確認するスレッドな高速化 => 非同期表示をマスターしてから
・ルーティングが微妙
・検索結果をセッションに保持する => 重い実装のため
・CSSがクールでない
・自由に並べ替えできるようにする(ajaxで)
・一括削除ボックス => 文献が古すぎて書き方がわからない。時間かかりすぎ。(http://wiki.fdiary.net/rails/?AjaxOnRails)
・メールやAPIで登録する的な
・そもそもリーン用と自分版をもうちとわかりやすくする。ディレクトリも整理する。

◆document
●linkchecker on rails
＜ユーザーストーリー＞
「時間がない自分」として
「複数あるブックマークされたWebサイトの生存確認」をしたい
なぜなら「いちいち開いている時間がない」からだ

◎恒久的な自分専用ブックマーク。
◎ひたすらURLを登録していく。
◎そのURLが死んでいるかどうかをラクに確認する。

しばらくは並行稼働をするが、いずれ「own」と「lean」に分岐する。
ownは自分が使いやすいようにカスタマイズしたモデル。
leanは外に公開し、リーンメソッドで運用していくモデル。
=================================================










2012/12/18 10:05
(id,title,url,tag,status,httpcode) values(1,たいとる,http〜,音楽,action,200)

rails g scaffold bookmarks name:string uri:string tag:string status:string httpcode:string
rake db:migrate

insert into bookmarks (title,uri,created_at,updated_at) values ('yahoo','http://yahoo.co.jp',0,0);


update_attribute(name, value)
record.update_attribute(:name, "column22")

update_attributes(attributes)
record.update_attributes(:column1 => "column11")

update(id, attribute)
SomeRecords.update([1, 2], [{ :column1 => "column111" }, { :column2 => "column222" }])

update_all(updates, conditions)
SomeRecord.update_all("column1='column1'", "id=1")

detele_all(conditions)
SomeRecords.delete_all("id = 1")

destroy_all(conditions)
delete_all(conditions)と違って、関連するテーブルのレコードも削除する

<% form_for(レコード名)　do |f| %>
f.label→labeのlabelタグを表示
f.text_field→textのinputタグを表示
f.date_select→モデルで設定したフィールドをselectタグで選べるようにして表示
f.check_box→checkboxのinputタグを表示
f.submit→submitのinputタグを表示
<% end %>

検索
def find
  @テーブル名 = レコード名.all
  (:conditions=>["キー= ? OR キー = ?", params[:search_string], params[:search_string]])
end


<% form_for :モデル名, 変数, :url => { :action => "create" } do |変数| %>
<% form_for :bookmark, @bookmark, :url => { :action => "create" } do |f| %>
<% form_for(@bookmark) do |f| %>


パラメータを受け取るためにはRack式にやらないとダメだった。

GETの場合
@env['rack.request.query_string']
Rack::Utils.parse_query(@env['rack.request.query_string'])

POSTの場合
@env['rack.request.form_vars']
Rack::Utils.parse_query(@env['rack.request.form_vars'])


◆テスト
get :edit, :id => 1
post :update, :id => 1, :customer => {:name => 'tom'}

セッションについては、@request.session に直接指定します。
@request.session["key"] = "value"

rake test
rake test:units
rake test:functionals
rake test:integration

$rake -T test:

rake test:recent 10分以内に変更されたモデルとコントローラを探し関連したテストを実行
rake test:single
rake test:uncommitted 最後のコミットに関連したモデルとコントローラを探し関連したテストを実行


rails3では"link_to_remote" がなくなり "link_to" , "button_to" などに ":remote => true" オプションで実装する

railsをproductionモードで実行する
$ rake environment RAILS_ENV=production migrate 

rails s -e production でOK


=================================================
◆Done
＊URLの登録ができる。DBに追加されること。
＊URLの生存確認ができる。生きてるリンクから200が返ってくること。
＊URLの削除(とりあえずチェックボックスで)。チェックしたレコードが削除されること。
＊生きてるリンクのフィルタリング。ステータスが"ok"のものだけ抽出されること。
＊link.rbのモジュール分割した
＊いろいろ忘れてしまったので再度線引き
＊肝心要のcheckerをもう一度検査→問題なかった
＊ディレクトリ内のARはリリース版と微妙に違うのでなんとかする。→いったん完成させてからにする


